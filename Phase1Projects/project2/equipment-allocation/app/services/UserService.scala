package services

import javax.inject._
import scala.concurrent.{ExecutionContext, Future}
import models.User
import repositories.UserRepository
import org.mindrot.jbcrypt.BCrypt
import java.time.Instant

/**
 * UserService provides higher-level business logic for user management.
 *
 * It acts as a middle layer between controllers and repositories,
 * performing tasks such as:
 *
 *   • Password hashing (BCrypt)
 *   • Validation and pre-processing of user data
 *   • Combining multiple repository operations into a single workflow
 *
 * The service is intentionally lightweight—repositories handle DB I/O,
 * while this service handles domain logic.
 *
 * @param userRepository the underlying repository for user persistence
 * @param ec execution context for asynchronous operations
 */
@Singleton
class UserService @Inject()(
                             userRepository: UserRepository
                           )(implicit ec: ExecutionContext) {

  /**
   * Retrieves a user by ID.
   *
   * @param id the user ID
   * @return a Future containing either Some(User) or None if not found
   */
  def getUser(id: Int): Future[Option[User]] =
    userRepository.findById(id)

  /**
   * Returns all active (non-deleted) users in the system.
   *
   * @return Future sequence of User models
   */
  def getAllUsers(): Future[Seq[User]] =
    userRepository.findAll()

  /**
   * Creates a new user with a securely hashed password.
   *
   * This method:
   *   • Hashes the user's password with BCrypt
   *   • Sets timestamps for createdAt and updatedAt
   *   • Delegates persistence to the UserRepository
   *
   * @param username unique username for login
   * @param plainPassword raw password (hashed before saving)
   * @param fullName full display name
   * @param email user email address
   * @param phone optional phone number
   * @param isActive whether the account is active
   * @param roles a list of RBAC roles assigned to the user
   * @return Future containing the newly created user ID
   */
  def createUser(
                  username: String,
                  plainPassword: String,
                  fullName: String,
                  email: String,
                  phone: Option[String],
                  isActive: Boolean,
                  roles: List[String]
                ): Future[Int] = {
    val hashed = BCrypt.hashpw(plainPassword, BCrypt.gensalt())
    val now    = Instant.now()

    val user = User(
      userId       = 0, // auto-generated by DB
      username     = username,
      passwordHash = hashed,
      fullName     = fullName,
      email        = email,
      phone        = phone,
      isActive     = isActive,
      createdAt    = now,
      updatedAt    = now,
      roles        = roles
    )

    userRepository.create(user)
  }

  /**
   * Updates an existing user.
   *
   * This method:
   *   • Fetches the existing user
   *   • Optionally hashes the new password
   *   • Updates the user record with new fields
   *
   * If the user is not found, it returns `false`.
   *
   * @param id user ID to update
   * @param fullName updated name
   * @param email updated email
   * @param phone updated optional phone number
   * @param isActive updated active/inactive status
   * @param roles updated assigned roles
   * @param newPlainPassword optional new password (hashed if provided)
   * @return Future[Boolean] — true if updated, false if user was not found
   */
  def updateUser(
                  id: Int,
                  fullName: String,
                  email: String,
                  phone: Option[String],
                  isActive: Boolean,
                  roles: List[String],
                  newPlainPassword: Option[String]
                ): Future[Boolean] = {
    userRepository.findById(id).flatMap {
      case Some(existing) =>
        val newPasswordHash = newPlainPassword match {
          case Some(pw) if pw.nonEmpty => BCrypt.hashpw(pw, BCrypt.gensalt())
          case _                       => existing.passwordHash
        }

        val updated = existing.copy(
          fullName     = fullName,
          email        = email,
          phone        = phone,
          isActive     = isActive,
          passwordHash = newPasswordHash,
          roles        = roles
        )

        userRepository.update(updated).map(_ > 0)

      case None =>
        Future.successful(false)
    }
  }

  /**
   * Soft-deletes a user.
   *
   * The actual deletion is managed by the repository,
   * which usually marks the row as `isDeleted = true`.
   *
   * @param id user ID to delete
   * @return Future[Boolean] — true if deleted, false otherwise
   */
  def deleteUser(id: Int): Future[Boolean] =
    userRepository.delete(id).map(_ > 0)
}
