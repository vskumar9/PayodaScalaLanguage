# ================================================================
#                 SERVER CONFIGURATION
# ================================================================
# Bind Play server to all network interfaces (required for Docker/Azure).
play.server.http.address = "0.0.0.0"

# Default application port (can be overridden via env PLAY_SERVER_PORT or -Dplay.server.http.port)
play.server.http.port = ${?PLAY_SERVER_PORT}
play.server.http.port = 9000

# Register HTTP security filters (JWT authentication).
play.http.filters = "security.Filters"

# Enable custom DI module (runs OverdueScheduler eagerly).
play.modules.enabled += "modules.Module"

# Overdue Scheduler timings
# initialDelay → wait time before first execution
# interval     → how often the scheduler runs (e.g., every 24 hours)
overdue.scheduler.initialDelay = ${?OVERDUE_SCHEDULER_INITIAL_DELAY}
overdue.scheduler.initialDelay = 30s
overdue.scheduler.interval = ${?OVERDUE_SCHEDULER_INTERVAL}
overdue.scheduler.interval = 24h


# ================================================================
#                 CORS CONFIGURATION
# ================================================================
# Enable Play's built-in CORS filter.
play.filters.enabled += "play.filters.cors.CORSFilter"

play.filters.cors {
  # Apply CORS only to API routes.
  pathPrefixes = ["/api"]

  # Allowed origins can be supplied via env CORS_ALLOWED_ORIGINS (a HOCON list)
  # Example in docker-compose: CORS_ALLOWED_ORIGINS='["https://app.example","https://admin.example"]'
  allowedOrigins = ${?CORS_ALLOWED_ORIGINS}
  # default to allow all (suitable for dev; lock down in prod)
  allowedOrigins = ["*"]

  # Allowed HTTP methods.
  allowedHttpMethods = ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"]

  # Allowed headers for browser requests.
  allowedHttpHeaders = ["Accept", "Origin", "Content-Type", "Authorization", "X-Auth-Token"]

  # Cache preflight OPTIONS request for 3 days.
  preflightMaxAge = 3 days
}


# ================================================================
#            DATABASE CONFIGURATION (Slick + MySQL)
# ================================================================
# Slick database profile (MySQL).
slick.dbs.default.profile = "slick.jdbc.MySQLProfile$"

# JDBC driver.
slick.dbs.default.db.driver = "com.mysql.cj.jdbc.Driver"

# Remote Azure MySQL connection string.
# Use DB_URL/DB_USER/DB_PASSWORD env vars when available (docker-friendly).
slick.dbs.default.db.url = ${?DB_URL}
slick.dbs.default.db.url = "jdbc:mysql://azuremysql8823.mysql.database.azure.com:3306/kumar"

# Database credentials (read from env if supplied)
slick.dbs.default.db.user = ${?DB_USER}
slick.dbs.default.db.user = "mysqladmin"

slick.dbs.default.db.password = ${?DB_PASSWORD}
slick.dbs.default.db.password = "Password@12345"

# Automatically apply SQL evolutions on startup.
play.evolutions.db.default.autoApply = true


# ================================================================
#                       JWT CONFIGURATION
# ================================================================
jwt {
  # Secret key for signing JWT tokens (must be strong in production).
  # Read from JWT_SECRET env when present.
  secret = ${?JWT_SECRET}
  secret = "equipment-allocation"

  # Token issuer field.
  issuer = ${?JWT_ISSUER}
  issuer = "equipment-allocation"

  # Token expiration time (in seconds). 86400 = 24 hours.
  expiration = ${?JWT_EXPIRATION}
  expiration = 86400
}


# ================================================================
#           PLAY APPLICATION SECRET (IMPORTANT!)
# ================================================================
# Use PLAY_HTTP_SECRET env in containers / prod. Fallback only for local/dev.
play.http.secret.key = ${?PLAY_HTTP_SECRET}
play.http.secret.key = "b0f4f35a4f9c4e8a9e8d1c7f3a8b2c5d7f9e1a3c4b6d8f0e2a4c6e8f0a2b4c"


# ================================================================
#                       KAFKA CONFIGURATION
# ================================================================
kafka {
  # Kafka broker URL (use docker-compose or external broker). Use env KAFKA_BOOTSTRAP_SERVERS in Docker.
  bootstrap.servers = ${?KAFKA_BOOTSTRAP_SERVERS}
  bootstrap.servers = "localhost:9092"

  topics {
    # Topic used for publishing equipment & inventory events.
    equipment = ${?KAFKA_TOPIC_EQUIPMENT}
    equipment = "equipment-events"
  }

  producer {
    # ACK strategy (all = safest delivery). Overridable via env KAFKA_PRODUCER_ACKS
    acks = ${?KAFKA_PRODUCER_ACKS}
    acks = "all"

    # Retry attempts for failed sends. Overridable via env KAFKA_PRODUCER_RETRIES
    retries = ${?KAFKA_PRODUCER_RETRIES}
    retries = 3

    # Delay before batching small messages (improves throughput). Overridable via env KAFKA_PRODUCER_LINGER_MS
    linger.ms = ${?KAFKA_PRODUCER_LINGER_MS}
    linger.ms = 5
  }
}
