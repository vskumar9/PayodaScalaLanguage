package repositories

import models.OverdueLog
import play.api.db.slick.{DatabaseConfigProvider, HasDatabaseConfigProvider}
import slick.jdbc.MySQLProfile

import java.sql.Timestamp
import java.time.Instant
import javax.inject._
import scala.concurrent.{ExecutionContext, Future}

/**
 * Repository for managing overdue reminder audit logs stored in the `overdue_logs` table.
 *
 * The **OverdueLogRepository** is responsible for storing and retrieving records of
 * overdue notifications that were sent to users. Each entry represents a single
 * reminder attempt (email/SMS/Slack/etc.), making this repository essential for:
 *
 * - Tracking escalation workflow (FIRST, SECOND, FINAL reminders)
 * - Preventing duplicate reminders from being sent
 * - Auditing and reporting overdue activity
 * - Providing history for administrators or automated systems
 *
 * ### Features
 * - Inserts overdue notification log entries.
 * - Fetches all logs or logs filtered by `allocationId`.
 * - Maps `Instant` to SQL `TIMESTAMP` through a Slick column mapping.
 * - Uses integer auto-increment primary keys.
 *
 * ### Table Structure: `overdue_logs`
 *
 * | Column                | Type        | Description                                  |
 * |-----------------------|------------|----------------------------------------------|
 * | overdue_id            | INT (PK)   | Auto-increment log ID                        |
 * | allocation_id         | INT        | Related equipment allocation                 |
 * | notified_at           | TIMESTAMP  | When the reminder was sent                   |
 * | reminder_type         | VARCHAR    | FIRST / SECOND / FINAL                       |
 * | recipient_employee_id | INT        | Employee receiving the reminder              |
 * | channel               | VARCHAR    | EMAIL / SMS / SLACK                          |
 *
 * @param dbConfigProvider Slick database configuration provider
 * @param ec Execution context for asynchronous DB operations
 */
@Singleton
class OverdueLogRepository @Inject()(
                                      protected val dbConfigProvider: DatabaseConfigProvider
                                    )(implicit ec: ExecutionContext)
  extends HasDatabaseConfigProvider[MySQLProfile] {

  import profile.api._

  /**
   * Implicit Slick column mapping for `Instant` â†” `Timestamp`.
   */
  implicit val instantColumnType: BaseColumnType[Instant] =
    MappedColumnType.base[Instant, Timestamp](
      i => Timestamp.from(i),
      ts => ts.toInstant
    )

  /**
   * Internal DB row representation for overdue logs.
   */
  private case class OverdueRow(
                                 overdueId: Int,
                                 allocationId: Int,
                                 notifiedAt: Instant,
                                 reminderType: String,
                                 recipientEmployeeId: Int,
                                 channel: String
                               )

  /**
   * Slick table mapping for the `overdue_logs` DB table.
   */
  private class OverdueLogsTable(tag: Tag) extends Table[OverdueRow](tag, "overdue_logs") {
    def overdueId           = column[Int]("overdue_id", O.PrimaryKey, O.AutoInc)
    def allocationId        = column[Int]("allocation_id")
    def notifiedAt          = column[Instant]("notified_at")
    def reminderType        = column[String]("reminder_type")
    def recipientEmployeeId = column[Int]("recipient_employee_id")
    def channel             = column[String]("channel")

    def * =
      (overdueId, allocationId, notifiedAt, reminderType, recipientEmployeeId, channel)
        .mapTo[OverdueRow]
  }

  private val overdueLogs = TableQuery[OverdueLogsTable]

  /**
   * Convert a DB row to the domain model [[OverdueLog]].
   */
  private def toModel(r: OverdueRow): OverdueLog =
    OverdueLog(
      overdueId           = r.overdueId,
      allocationId        = r.allocationId,
      notifiedAt          = r.notifiedAt,
      reminderType        = r.reminderType,
      recipientEmployeeId = r.recipientEmployeeId,
      channel             = r.channel
    )

  /**
   * Insert a new overdue log entry.
   *
   * @param log The domain log model to insert
   * @return Future containing the generated overdueId
   */
  def create(log: OverdueLog): Future[Int] = {
    val now = log.notifiedAt
    val row = OverdueRow(
      overdueId = 0, // Will be generated by DB
      allocationId = log.allocationId,
      notifiedAt = now,
      reminderType = log.reminderType,
      recipientEmployeeId = log.recipientEmployeeId,
      channel = log.channel
    )

    db.run((overdueLogs returning overdueLogs.map(_.overdueId)) += row)
  }

  /**
   * Fetch all overdue notification records.
   *
   * @return Future sequence of OverdueLog
   */
  def findAll(): Future[Seq[OverdueLog]] =
    db.run(overdueLogs.result).map(_.map(toModel))

  /**
   * Fetch overdue logs related to a specific equipment allocation.
   *
   * Useful for:
   *   - Preventing duplicate reminders
   *   - Viewing escalation history
   *   - Generating audit reports
   *
   * @param allocationId ID of the related allocation
   * @return Future sequence of OverdueLog for that allocation
   */
  def findByAllocation(allocationId: Int): Future[Seq[OverdueLog]] =
    db.run(overdueLogs.filter(_.allocationId === allocationId).result).map(_.map(toModel))
}
