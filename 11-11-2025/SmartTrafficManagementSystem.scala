import java.io.FileInputStream
import java.sql._
import java.util.Properties
import scala.util.Using
import java.time.LocalDateTime
import scala.collection.mutable.ListBuffer
import scala.util.{Try, Success, Failure}

/** Represents a vehicle registered in the traffic system.
  *
  * @param vehicleId
  *   Optional unique ID assigned by the database.
  * @param licensePlate
  *   License plate number of the vehicle.
  * @param vehicleType
  *   Type of vehicle (e.g., car, bike, truck).
  * @param ownerName
  *   Full name of the vehicle owner.
  */
case class Vehicle(
    vehicleId: Option[Int] = None,
    licensePlate: String,
    vehicleType: String,
    ownerName: String
) {

  /** Returns a formatted string representation for table display. */
  override def toString: String =
    f"${vehicleId.getOrElse("")}%-10s | $licensePlate%-15s | $vehicleType%-12s | $ownerName%-15s"
}

/** Represents a traffic signal in the system.
  *
  * @param signalId
  *   Optional unique ID generated by the database.
  * @param location
  *   Physical location of the traffic signal.
  * @param status
  *   Current signal state (green/yellow/red).
  */
case class TrafficSignal(
    signalId: Option[Int] = None,
    location: String,
    status: String
) {

  /** Returns a formatted string representation for table display. */
  override def toString: String = {
    f"${signalId.getOrElse("")}%-10s | $location%-20s | $status%-10s"
  }

}

/** Represents a traffic violation event recorded in the system.
  *
  * @param violationId
  *   Optional unique ID assigned by the database.
  * @param vehicleId
  *   ID of the involved vehicle.
  * @param signalId
  *   ID of the traffic signal where violation occurred.
  * @param violationType
  *   Type of violation (e.g., speeding, signal jump).
  * @param timestamp
  *   Time the violation occurred.
  */
case class Violation(
    violationId: Option[Int] = None,
    vehicleId: Int,
    signalId: Int,
    violationType: String,
    timestamp: LocalDateTime = LocalDateTime.now()
) {

  /** Returns a formatted string representation for table display. */
  override def toString: String = {
    f"${violationId.getOrElse("")}%-12s | $vehicleId%-10d | $signalId%-10d | $violationType%-15s | $timestamp%-20s"
  }

}

/** Utility object responsible for handling database connections,
  * initialization, and table creation.
  *
  * Loads configuration from a properties file, checks database existence,
  * creates tables, and provides ready-to-use connections.
  */
object DatabaseUtil {
  private val prop: Properties = new Properties()

  /** Loads database configuration from properties file and initializes the
    * driver. Executed only once.
    */
  private def loadProperties(): Unit = {
    if (prop.isEmpty) {
      Using.resource(new FileInputStream("11-11-2025/DB.properties")) { file =>
        prop.load(file)
        Class.forName(prop.getProperty("DB_DRIVER_CLASS"))
      }
    }
  }

  /** Establishes a connection to the MySQL server (without selecting DB). */
  private def getServerConnection(): Connection = {
    loadProperties()
    DriverManager.getConnection(
      prop.getProperty("DB_URL"),
      prop.getProperty("DB_USERNAME"),
      prop.getProperty("DB_PASSWORD")
    )
  }

  /** Returns a connection to the target database. Creates the database and
    * required tables if they do not exist.
    */
  def getConnection(): Connection = {
    loadProperties()
    val databaseName = prop.getProperty("DB_DATABASE_NAME")
    if (!databaseExists(databaseName)) {
      createDatabase(databaseName)
    }

    val conn = DriverManager.getConnection(
      s"${prop.getProperty("DB_URL")}/$databaseName",
      prop.getProperty("DB_USERNAME"),
      prop.getProperty("DB_PASSWORD")
    )

    val tableNames = List("Vehicles", "TrafficSignals", "Violations")
    if (tableNames.exists(tableName => !tableExists(conn, tableName))) {
      createTables(conn)
    }
    conn
  }

  /** Checks whether the target database exists.
    *
    * @param dbName
    *   Name of the database to check.
    */
  private def databaseExists(dbName: String): Boolean = {
    Using.resource(getServerConnection()) { conn =>
      val query = "SHOW DATABASES LIKE ?"
      Using.resource(conn.prepareStatement(query)) { pstmt =>
        pstmt.setString(1, dbName)
        Using.resource(pstmt.executeQuery()) { rs =>
          rs.next()
        }
      }
    }
  }

  /** Creates the database if it does not exist. */
  private def createDatabase(dbName: String): Unit = {
    Using.resource(getServerConnection()) { conn =>
      Using.resource(conn.createStatement()) { stmt =>
        stmt.executeUpdate(s"CREATE DATABASE $dbName")
        println(s"Database '$dbName' created.")
      }
    }
  }

  /** Checks whether a particular table exists in the database.
    *
    * @param conn
    *   Active DB connection
    * @param tableName
    *   Name of the table to verify
    */
  private def tableExists(conn: Connection, tableName: String): Boolean = {
    val query = "SHOW TABLES LIKE ?"
    Using.resource(conn.prepareStatement(query)) { pstmt =>
      pstmt.setString(1, tableName)
      Using.resource(pstmt.executeQuery()) { rs =>
        rs.next()
      }
    }
  }

  /** Creates tables Vehicles, TrafficSignals, and Violations if missing.
    *
    * @param conn
    *   Active connection to the database.
    */
  private def createTables(conn: Connection): Unit = {
    val createVehiclesTable =
      """
        |CREATE TABLE IF NOT EXISTS Vehicles (
        | vehicle_id INT PRIMARY KEY AUTO_INCREMENT,
        | license_plate VARCHAR(20),
        | vehicle_type VARCHAR(20),
        | owner_name VARCHAR(100)
        |)
        |""".stripMargin

    val createTrafficSignalsTable =
      """
        |CREATE TABLE IF NOT EXISTS TrafficSignals (
        | signal_id INT PRIMARY KEY AUTO_INCREMENT,
        | location VARCHAR(100),
        | status VARCHAR(10)
        |)
        |""".stripMargin

    val createViolationsTable =
      """
        |CREATE TABLE IF NOT EXISTS Violations (
        | violation_id INT PRIMARY KEY AUTO_INCREMENT,
        | vehicle_id INT,
        | signal_id INT,
        | violation_type VARCHAR(50),
        | timestamp DATETIME,
        | FOREIGN KEY (vehicle_id) REFERENCES Vehicles(vehicle_id),
        | FOREIGN KEY (signal_id) REFERENCES TrafficSignals(signal_id)
        |)
        |""".stripMargin

    Using.resource(conn.createStatement()) { stmt =>
      stmt.executeUpdate(createVehiclesTable)
      stmt.executeUpdate(createTrafficSignalsTable)
      stmt.executeUpdate(createViolationsTable)
      println("Tables created or already exist.")
    }
  }
}

/** Data Access Object (DAO) containing CRUD operations for Vehicles, Traffic
  * Signals, and Violations.
  *
  * Provides high-level functions used by the main menu UI.
  */
object TrafficDAO {

  /** Inserts a new vehicle record.
    *
    * @param vehicle
    *   Vehicle data to insert.
    * @return
    *   true if insert succeeded, false otherwise.
    */
  def addVehicle(vehicle: Vehicle): Boolean = {
    val sql =
      "INSERT INTO Vehicles (license_plate, vehicle_type, owner_name) VALUES (?, ?, ?)"
    try {
      Using.resource(DatabaseUtil.getConnection()) { conn =>
        Using.resource(conn.prepareStatement(sql)) { pstmt =>
          pstmt.setString(1, vehicle.licensePlate)
          pstmt.setString(2, vehicle.vehicleType)
          pstmt.setString(3, vehicle.ownerName)
          pstmt.executeUpdate() > 0
        }
      }
    } catch {
      case e: Exception =>
        println(s"Error adding vehicle: ${e.getMessage}")
        false
    }
  }

  /** Inserts a new traffic signal into the database.
    *
    * @param signal
    *   Traffic signal to insert.
    */
  def addTrafficSignal(signal: TrafficSignal): Boolean = {
    val sql = "INSERT INTO TrafficSignals (location, status) VALUES (?, ?)"
    try {
      Using.resource(DatabaseUtil.getConnection()) { conn =>
        Using.resource(conn.prepareStatement(sql)) { pstmt =>
          pstmt.setString(1, signal.location)
          pstmt.setString(2, signal.status)
          pstmt.executeUpdate() > 0
        }
      }
    } catch {
      case _: Exception =>
        false
    }
  }

  /** Records a traffic violation event. Ensures the referenced vehicle exists
    * before inserting.
    *
    * @param violation
    *   Violation details.
    * @return
    *   true if successful, false if vehicle does not exist or error.
    */
  def recordViolation(violation: Violation): Boolean = {
    val checkVehicleSql = "SELECT vehicle_id FROM Vehicles WHERE vehicle_id = ?"
    val insertViolationSql =
      "INSERT INTO Violations (vehicle_id, signal_id, violation_type, timestamp) VALUES (?, ?, ?, ?)"
    try {
      Using.resource(DatabaseUtil.getConnection()) { conn =>
        Using.resource(conn.prepareStatement(checkVehicleSql)) { checkStmt =>
          checkStmt.setInt(1, violation.vehicleId)
          Using.resource(checkStmt.executeQuery()) { rs =>
            if (rs.next()) {
              Using.resource(conn.prepareStatement(insertViolationSql)) {
                pstmt =>
                  pstmt.setInt(1, violation.vehicleId)
                  pstmt.setInt(2, violation.signalId)
                  pstmt.setString(3, violation.violationType)
                  pstmt.setTimestamp(4, Timestamp.valueOf(violation.timestamp))
                  pstmt.executeUpdate() > 0
              }
            } else {
              false
            }
          }
        }
      }
    } catch {
      case _: Exception => false
    }
  }

  /** Updates the status of a traffic signal.
    *
    * @param signalId
    *   ID of the signal to update.
    * @param newStatus
    *   New status (green, yellow, red).
    */
  def updateSignalStatus(signalId: Int, newStatus: String): Boolean = {
    val sql = "UPDATE TrafficSignals SET status = ? WHERE signal_id = ?"
    try {
      Using.resource(DatabaseUtil.getConnection()) { conn =>
        Using.resource(conn.prepareStatement(sql)) { pstmt =>
          pstmt.setString(1, newStatus)
          pstmt.setInt(2, signalId)
          pstmt.executeUpdate() > 0
        }
      }
    } catch {
      case _: Exception => false
    }
  }

  /** Retrieves all vehicles from the database. */
  def viewVehicles(): List[Vehicle] = {
    val sql = "SELECT * FROM Vehicles"
    val vehicles = ListBuffer.empty[Vehicle]
    Using.resource(DatabaseUtil.getConnection()) { conn =>
      Using.resource(conn.createStatement()) { stmt =>
        Using.resource(stmt.executeQuery(sql)) { rs =>
          while (rs.next()) {
            vehicles += Vehicle(
              vehicleId = Some(rs.getInt("vehicle_id")),
              licensePlate = rs.getString("license_plate"),
              vehicleType = rs.getString("vehicle_type"),
              ownerName = rs.getString("owner_name")
            )

          }
        }
      }
    }
    vehicles.toList
  }

  /** Retrieves all traffic signals. */
  def viewSignals(): List[TrafficSignal] = {
    val sql = "SELECT * FROM TrafficSignals"
    val signals = ListBuffer.empty[TrafficSignal]
    Using.resource(DatabaseUtil.getConnection()) { conn =>
      Using.resource(conn.createStatement()) { stmt =>
        Using.resource(stmt.executeQuery(sql)) { rs =>
          while (rs.next()) {
            signals += TrafficSignal(
              signalId = Some(rs.getInt("signal_id")),
              location = rs.getString("location"),
              status = rs.getString("status")
            )

          }
        }
      }
    }
    signals.toList
  }

  /** Retrieves all recorded violations. */
  def viewViolations(): List[Violation] = {
    val sql = "SELECT * FROM Violations"
    val violations = ListBuffer.empty[Violation]
    Using.resource(DatabaseUtil.getConnection()) { conn =>
      Using.resource(conn.createStatement()) { stmt =>
        Using.resource(stmt.executeQuery(sql)) { rs =>
          while (rs.next()) {
            violations += Violation(
              violationId = Some(rs.getInt("violation_id")),
              vehicleId = rs.getInt("vehicle_id"),
              signalId = rs.getInt("signal_id"),
              violationType = rs.getString("violation_type"),
              timestamp = rs.getTimestamp("timestamp").toLocalDateTime
            )

          }
        }
      }
    }
    violations.toList
  }

  /** Deletes a vehicle by ID. */
  def deleteVehicle(vehicleId: Int): Boolean = {
    val sql = "DELETE FROM Vehicles WHERE vehicle_id = ?"
    try {
      Using.resource(DatabaseUtil.getConnection()) { conn =>
        Using.resource(conn.prepareStatement(sql)) { pstmt =>
          pstmt.setInt(1, vehicleId)
          pstmt.executeUpdate() > 0
        }
      }
    } catch {
      case _: Exception => false
    }
  }

  /** Deletes a violation by ID. */
  def deleteViolation(violationId: Int): Boolean = {
    val sql = "DELETE FROM Violations WHERE violation_id = ?"
    try {
      Using.resource(DatabaseUtil.getConnection()) { conn =>
        Using.resource(conn.prepareStatement(sql)) { pstmt =>
          pstmt.setInt(1, violationId)
          pstmt.executeUpdate() > 0
        }
      }
    } catch {
      case _: Exception => false
    }
  }

  /** Deletes a traffic signal by ID. */
  def deleteTrafficSignal(signalId: Int): Boolean = {
    val sql = "DELETE FROM TrafficSignals WHERE signal_id = ?"
    try {
      Using.resource(DatabaseUtil.getConnection()) { conn =>
        Using.resource(conn.prepareStatement(sql)) { pstmt =>
          pstmt.setInt(1, signalId)
          pstmt.executeUpdate() > 0
        }
      }
    } catch {
      case _: Exception => false
    }
  }

}

/** Console-based user interface loop for the Smart Traffic Management System.
  *
  * This interactive loop presents a menu of operations to the user and
  * dispatches requests to the [[TrafficDAO]] for CRUD and query operations.
  *
  * Menu options:
  *   1. Add Vehicle - Prompts for license plate, type and owner; inserts a
  *      vehicle. 2. Delete Vehicle - Prompts for vehicle ID and deletes the
  *      corresponding record. 3. Add Traffic Signal - Prompts for location and
  *      status; inserts a traffic signal. 4. Delete Traffic Signal - Prompts
  *      for signal ID and deletes the corresponding record. 5. Record Violation
  *      \- Prompts for vehicle ID, signal ID and violation type; records a
  *      violation. 6. Delete Violation - Prompts for violation ID and deletes
  *      the corresponding record. 7. Update Signal Status - Prompts for signal
  *      ID and new status; updates the signal record. 8. View Vehicles -
  *      Displays a formatted list of all vehicles. 9. View Traffic Signals -
  *      Displays a formatted list of all traffic signals.
  * 10. View Violations - Displays a formatted list of all recorded violations.
  * 11. Exit - Exits the interactive loop and terminates the program.
  */
object SmartTrafficManagementSystem extends App {
  var running = true

  def readInt(prompt: String): Option[Int] = {
    println(prompt)
    Try(scala.io.StdIn.readLine().trim.toInt) match {
      case Success(value) => Some(value)
      case Failure(_) =>
        println("Invalid number, please try again.")
        None
    }
  }

  def readNonEmptyString(prompt: String): Option[String] = {
    println(prompt)
    val input = scala.io.StdIn.readLine().trim
    if (input.nonEmpty) Some(input)
    else {
      println("Input cannot be empty.")
      None
    }
  }

  def validateStatus(status: String): Boolean = {
    Set("green", "yellow", "red").contains(status.toLowerCase)
  }

  def addVehicle(): Unit = {
    for {
      plate <- readNonEmptyString("License Plate:")
      vtype <- readNonEmptyString("Vehicle Type (car, bike, truck):")
      owner <- readNonEmptyString("Owner Name:")
    } {
      val added = TrafficDAO.addVehicle(
        Vehicle(licensePlate = plate, vehicleType = vtype, ownerName = owner)
      )
      if (added) println("Vehicle added successfully.")
      else println("Failed to add vehicle.")
    }
  }

  def deleteVehicle(): Unit = {
    readInt("Vehicle ID to delete:").foreach { vid =>
      val deleted = TrafficDAO.deleteVehicle(vid)
      if (deleted) println(s"Vehicle ID $vid deleted successfully.")
      else println(s"Vehicle ID $vid not found.")
    }
  }

  def addTrafficSignal(): Unit = {
    for {
      location <- readNonEmptyString("Signal Location:")
      status <- {
        val s = scala.io.StdIn
          .readLine("Status (green, yellow, red):")
          .trim
          .toLowerCase
        if (validateStatus(s)) Some(s)
        else {
          println("Invalid status. Must be one of green, yellow, red.")
          None
        }
      }
    } {
      val added = TrafficDAO.addTrafficSignal(
        TrafficSignal(location = location, status = status)
      )
      if (added) println("Traffic signal added successfully.")
      else println("Failed to add traffic signal.")
    }
  }

  def deleteTrafficSignal(): Unit = {
    readInt("Traffic Signal ID to delete:").foreach { sid =>
      val deleted = TrafficDAO.deleteTrafficSignal(sid)
      if (deleted) println(s"Traffic Signal ID $sid deleted successfully.")
      else println(s"Traffic Signal ID $sid not found.")
    }
  }

  def recordViolation(): Unit = {
    for {
      vid <- readInt("Vehicle ID:")
      sid <- readInt("Signal ID:")
      vtype <- readNonEmptyString("Violation Type (speeding, signal jump):")
    } {
      val added = TrafficDAO.recordViolation(
        Violation(vehicleId = vid, signalId = sid, violationType = vtype)
      )
      if (added) println("Violation recorded successfully.")
      else
        println(s"Failed to record violation; vehicle ID $vid may not exist.")
    }
  }

  def deleteViolation(): Unit = {
    readInt("Violation ID to delete:").foreach { violationId =>
      val deleted = TrafficDAO.deleteViolation(violationId)
      if (deleted) println(s"Violation ID $violationId deleted successfully.")
      else println(s"Violation ID $violationId not found.")
    }
  }

  def updateSignalStatus(): Unit = {
    for {
      sid <- readInt("Signal ID:")
      newStatus <- {
        val s = scala.io.StdIn
          .readLine("New Status (green, yellow, red):")
          .trim
          .toLowerCase
        if (validateStatus(s)) Some(s)
        else {
          println("Invalid status. Must be one of green, yellow, red.")
          None
        }
      }
    } {
      val updated = TrafficDAO.updateSignalStatus(sid, newStatus)
      if (updated) println("Signal status updated successfully.")
      else println("Signal ID not found or update failed.")
    }
  }

  def viewVehicles(): Unit = {
    val vehicles = TrafficDAO.viewVehicles()
    println(
      f"${"vehicle_id"}%-10s | ${"license_plate"}%-15s | ${"vehicle_type"}%-12s | ${"owner_name"}%-15s"
    )
    println("-" * 60)
    if (vehicles.nonEmpty) vehicles.foreach(println) else println("No Data.")
  }

  def viewSignals(): Unit = {
    val signals = TrafficDAO.viewSignals()
    println(f"${"signal_id"}%-10s | ${"location"}%-20s | ${"status"}%-10s")
    println("-" * 50)
    if (signals.nonEmpty) signals.foreach(println) else println("No Data.")
  }

  def viewViolations(): Unit = {
    val violations = TrafficDAO.viewViolations()
    println(
      f"${"violation_id"}%-10s | ${"vehicle_id"}%-10s | ${"signal_id"}%-10s | ${"violation_type"}%-15s | ${"timestamp"}%-20s"
    )
    println("-" * 90)
    if (violations.nonEmpty) violations.foreach(println)
    else println("No Data.")
  }

  while (running) {
    println(
      """
      |Smart Traffic Management System
      |1. Add Vehicle
      |2. Delete Vehicle
      |3. Add Traffic Signal
      |4. Delete Traffic Signal
      |5. Record Violation
      |6. Delete Violation
      |7. Update Signal Status
      |8. View Vehicles
      |9. View Traffic Signals
      |10. View Violations
      |11. Exit
      |Enter your choice:
      |""".stripMargin
    )

    scala.io.StdIn.readLine().trim.toIntOption match {
      case Some(choice) =>
        choice match {
          case 1  => addVehicle()
          case 2  => deleteVehicle()
          case 3  => addTrafficSignal()
          case 4  => deleteTrafficSignal()
          case 5  => recordViolation()
          case 6  => deleteViolation()
          case 7  => updateSignalStatus()
          case 8  => viewVehicles()
          case 9  => viewSignals()
          case 10 => viewViolations()
          case 11 =>
            println("Exiting...")
            running = false
          case _ => println("Invalid input. Try again.")
        }
      case None =>
        println("Please enter a valid number.")
    }
  }

}
